TODO:
    Υλοποίηση της random (γινεται μεσο της sort (test it)) (UCS)
    (IDS) Το κομμάτι που ελέγχει το βάθος
   Υλοποίηση μιας heuristic
        idea: απόσταστη (διαγώνιας) απο τον G (αν το G είναι πάντα σε σταθερο σημείο)
   Πάρε τον IDS απο τον παλέγκα




Υλοποίσεις:
    Μιας και "επιτρέπεται" να "ξέρουμνε" που βρίσκεται το G
    Τότε μπορούμε να τρέξουμε μια διπλή for στον πίνακα για βρίσκει
        το G και να εφαρμωζεί manhatan/ότι να ΄ναι στην θέση εκεινη

    Για μια αρχή θα το κάνω με διαγώνιο δλδ
    σημείο που ειμαστε (x0,y0), σημείω G (xg, yg) η απόσταση
        μεταξύ τους ειναι sgrt((x0-xg)^2 + (y0-yg)^2) (μετρο μιγαδικου)



Επιστροφή του μονοπατοιού:
    Για να το καταφέρω αυτο(και γρήγορα), τώρα πια το fathernode είναι ενα Node απο μονό του
    και στην λουπα που επιστρέφει, του λεμε να συνεχια tmpnode = tmpnode.fathernode
    και εκτυπωνω αντιστοιχα

    ομως επεπε να αλλάξει ο έλεγχος για την πρως τα πίσω κινηση σε node.fathernode.state
    και επισης η αρχικοποιηση ηταν λιγο κάπως

To talk about:
    Αν πραγματικά ειναι IDS ο IDS που έκανς

    Ίσως δεν χρεάζετε να κάνουμε την random μιας και το κάνει η sort
        κρατάει τις ίδιες τιμες εκεί που τις βρήκε.


Αναλυση:
    Σε μια επανάληψη, εχει παρει τον πρωτο γειτονηκο κομβο και τον εχει επεκτηνει
        εχει φτασει στα παιδια των(του) παιδιων

    Σε μια λουπα της while δλδ και πριν:
    εχουμε ηδη επεκτινει το startnode με την makeQueue πριν την while
    οταν μπηκε στην while, βγαλαμε το startnode
    και επεκτιναμε μετα ενα απο τα παιδια του startnode

    αλλα δεν εχει μπει το startnode στην Previusly..

    Υλοποιείται το random με την sort απλά δεν ξέρουμε πως το κανει
        sort

    στον ελεγχο για προηγουμενη επισκεψη
        ο παλεγκας το εκανε να βλεπει να η τορινη κατασταση που προκειται να επεκταθει
        ειναι στην previouslyvisited να βγαζει το πρωτο κομβο απο την queue

        θα το αλλαξω εγω σε:
            πριν παρει τον επομενο κομβο θα διατρεχει και θα ελγχει:
            για καθε στοιχειο της queue αν υπαρχει στην previouslyvisited
            θα το βγζει απο την queue
                απο 170 -> 95

    Κομπλε ειναι ο αλγορυθμος εν τελει, βρισκει το συντομοτερο αλλα εχει τεραστιο
    μετοπο αναζήτησης
        στο οποιο εμφανίζεται ο ιδιος κομβος πολλες φορες

        ->fix: αν ελεγχω και αποτρεπω τις προς τα πισω κινησεις απο 10025 κομβους παμε στους 25
          τροπος:
           Αν η κατασταση που παει να δημιουργιθει εχει ιδια τιμη με την κατασταση του
           παπου της τοτε προκειται για πρως τα πισο κινηση

            it worked (με 1190945454 κομβους)


    στην while τώρα έχουμε έλεγχο για το που ακριβώς μπαίνουν τα νέα παιδια που εξερυνήστικαν

    Στον UCS: μπαινουν στο τέλος της ουράς
    Στον DFS(για IDS): μπαινουν στην αρχή

    IDS:
        Ο DFS υλοποιήται βάζοντας τα αποτελέσματα της makeQueue, στην αρχή της queue (queue = makeQueue + queue)

        Μία εσωτερική λουπα τώρα πια κάνει την αναζήτηση
            Η οποία τρέχει απεριόροστα μέχρι που είτε φτάνει στο όριο βάθους, ειτε βρήσκει τον G
        Στην εξωτερική κάθε φορα αρχικοποιούνται οι τιμές και αυξάνεται το βάθος

    Μιας και η makeQueue, δεν αλλάζει την καλουν και ο IDS, και ο UCS
        Τώρα πια το όνομα του αρχείου του λαβυρινθου, μπαίνει σαν παράμετρος
        στην κλήση του αλγορίθμου.





